/* zt_common_h.in -- Process this file with configure to produce common.h */

extern char *memoryError;
#define zt_callocs(size, num)     (xcalloc ((num), (size)))
#define zt_mallocs(size, num)     (xmalloc ((num) * (size)))
#define zt_calloc(type, num)	((type *) xcalloc ((num), sizeof(type)))
#define zt_malloc(type, num)	((type *) xmalloc ((num) * sizeof(type)))
#define zt_realloc(type, p, num)	((type *) xrealloc (((void_p)p), (num) * sizeof(type)))
#define zt_free(stale)   	  	       	  	   	 \
do {							 \
   if (stale) { free ((void_p) stale);  stale = 0; }	 \
} while(0)
#define zt_strdup xstrdup

BEGIN_C_DECLS

/* These entry points to the API are guaranteed to be functions */

extern void_p zt_calloc_p	(size_t num, size_t size);
extern void_p zt_malloc_p	(size_t num);
extern void_p zt_realloc_p (void_p p, size_t num);
extern void zt_free_p (void_p stale);
extern char *zt_strdup_p (const char *string);

END_C_DECLS

/* Let dmalloc provide mainstream `x' family mallocation API, or else
   provide our own which points to the `f_' family above.  Note that
   when using dmalloc, the functions wrapped by my `f_' API will be
   (correctly) redefined to use the dmalloc library. */

#if WITH_DMALLOC
#  include <dmalloc.h>
#else
#  define xcalloc  zt_calloc_p
#  define xmalloc  zt_malloc_p
#  define xrealloc zt_realloc_p
#  define xfree    zt_free_p
#endif
#define xstrdup zt_strdup_p
