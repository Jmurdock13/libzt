#!/bin/sh
AUTHOR='Jason L. Shiffer || Mark Ellzey'
EMAIL='<jshiffer@zerotao.org>, <ellzey@strcpy.net>'
OWNER='Jason L. Shiffer || Mark Ellzey'

put_header() {
    out=$1
    header=$2
    DN=`dirname $0`


    if [ x"$header" != x"" -a -e "$header" ]; then
        cat $header > $out
    else
        # check to see if you are using an explicit or implicit path
        if [ -e $DN/zt_hdr ]; then
            ZT_HDR="$DN/zt_hdr"
        else
            ZT_HDR="zt_hdr"
        fi

        $ZT_HDR -A "$AUTHOR" -E "$EMAIL" -O "$OWNER" $out
    fi
}

put_component_c() {
    file=$1
    cfname=$2
    cname=$3
    prefix=$4
    header=$5

    put_header "$file" "$header"

    CFNAME=`echo ${cfname} | tr 'a-z' 'A-Z'`

    cat >> ${file} <<EOF
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /* HAVE_CONFIG_H */

#include <stdlib.h>

#define ${CFNAME}_PRIVATE
#include "${cfname}.h"
#undef ${CFNAME}_PRIVATE

void ${prefix}${cname}_destroy(${prefix}${cname} **${cname})
{
    if(*${cname} && (*${cname})->vtbl->destructor) {
        (*${cname})->vtbl->destructor(*${cname});
    }
    *${cname} = NULL;
}


/* private side */
${prefix}${cname} *
${prefix}${cname}_new(${prefix}${cname}_vtbl * vptr)
{
    ${prefix}${cname}    * result;

    if ((result = calloc(1, vptr->size)) == NULL) {
        return NULL;
    }
    result->vtbl = vptr;
    return(result);
}
EOF
}

put_component_h() {
    file=$1
    cfname=$2
    cname=$3
    prefix=$4
    header=$5

    shift 5

    put_header "$file" "$header"

    CFNAME=`echo ${cfname} | tr 'a-z' 'A-Z'`

    cat >> ${file} <<EOF
#ifndef _${CFNAME}_H_
#define _${CFNAME}_H_

#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

typedef struct ${prefix}${cname} ${prefix}${cname};

void ${prefix}${cname}_destroy(${prefix}${cname} **${cname});

#ifdef ${CFNAME}_PRIVATE
/* function pointer table */
struct ${prefix}${cname}_vtbl {
    size_t    size;         /* contains the size of the (sub)class definition */

    /* virtual function pointers */
    void    (*destructor)(${prefix}${cname} *);
};

/* base class definition */
typedef struct ${prefix}${cname}_vtbl ${prefix}${cname}_vtbl;
struct ${prefix}${cname} {
    /* base class attributes */

    /* end base class attributes */
    struct ${prefix}${cname}_vtbl   * vtbl;
};

/* base allocator */
${prefix}${cname} * ${prefix}${cname}_new(${prefix}${cname}_vtbl * vptr);
#endif /* ${CFNAME}_PRIVATE */

#ifdef __cplusplus
}
#endif /* __cplusplus */

/* sub-class headers */
EOF
    for sub in $@; do
        cat >> ${file} <<EOF
#include <${cfname}/${cfname}_${sub}.h>
EOF
    done

    cat >> ${file} <<EOF
#endif /* _${CFNAME}_H_ */
EOF
}

put_sub_h() {
    file=$1
    cfname=$2
    cname=$3
    prefix=$4
    header=$5
    sub=$6

    CFNAME=`echo ${cfname} | tr 'a-z' 'A-Z'`
    SUB=`echo ${sub} | tr 'a-z' 'A-Z'`

    put_header "$file" "$header"

    cat >> ${file} <<EOF
#ifndef _${CFNAME}_${SUB}_H_
#define _${CFNAME}_${SUB}_H_

#include <${cfname}/${cfname}.h>

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

extern ${prefix}${cname} * ${prefix}${cname}_${sub}(void);

#ifdef __cplusplus
}
#endif /* __cplusplus */
#endif /* _${CFNAME}_${SUB}_H_ */
EOF

}

put_sub_c() {
    file=$1
    cfname=$2
    cname=$3
    prefix=$4
    header=$5
    sub=$6

    put_header "$file" "$header"

    cat >> ${file} <<EOF
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /* HAVE_CONFIG_H */

#define ${CFNAME}_PRIVATE
#include "${cname}.h"
#undef ${CFNAME}_PRIVATE

/* locals */
static void destructor(${prefix}${cname} * ${cname});

/* cname data */
struct ${prefix}${cname}_${sub} {
    ${prefix}${cname}     parent;
    /* sub class locals */
};

static ${prefix}${cname}_vtbl vtbl = {
    sizeof(struct ${prefix}${cname}_$sub),
    destructor,
};

${prefix}${cname} * ${prefix}${cname}_${sub}(void)
{
    ${prefix}${cname}               * result;
    struct ${prefix}${cname}_${sub} * ${sub};

    if ((result = ${prefix}${cname}_new(&vtbl)) == NULL) {
        return NULL;
    }

    ${sub} = (struct ${prefix}${cname}_${sub} *)result;

    /* local setup here */

    return result;
}

/* local destructor */
static void destructor(${prefix}${cname} * ${cname})
{
    struct ${prefix}${cname}_${sub}    * ${sub};
    ${sub} = (struct ${prefix}${cname}_${sub} *)${cname};

    return;
}

EOF

}

usage() {
    cat <<EOF
usage:
$0 [opts] [cname] [[sub] [...]]

opts:
-h          this help text
-m          generate a Makefile.am
-o          overwrite files
-p<prefix>  prefix to use for structures and functions
-d<dir>     directory to generate the component (defile $PWD)
-H<file>    file to use as a header for generated files
-f<cfname>  use <cfname> for the file names (default <cname>)
-O<OWNER>   Owner to use in comments
-A<AUTHOR>  Author to use in comments
-E<EMAIL>   Email to use in comments

files are generated thus:
  <cfname>.h
  <cfname>.c
  <cfname>_<sub>.h
  <cfname>_<sub>.c
  ...
EOF
}



# main
base_dir="."
gen_make=0
overwrite=0
header=""
prefix=""
cfname=""

while getopts "mohp:H:d:f:O:A:E:" flag
do
    case "$flag" in
        m)
            gen_make=1
            ;;
        o)
            overwrite=1
            ;;
        h)
            usage
            exit 0
            ;;
        p)
            prefix=$OPTARG
            ;;
        d)
            base_dir=$OPTARG
            ;;
        f)
            cfname=$OPTARG
            ;;
        H)
            header=$OPTARG
            ;;
        O)
            OWNER=$OPTARG
            ;;
        A)
            AUTHOR=$OPTARG
            ;;
        E)
            EMAIL=$OPTARG
            ;;
        *)
            echo "Unknown option $flag"
            usage
            exit 1
            ;;
    esac
done
shift $((${OPTIND}-1))

if [ $# == 0 ]; then
    usage
    exit
fi

cname=$1; shift;

if [ x"$cfname" == x"" ]; then
    cfname=${cname}
fi


# check files
if [ $overwrite == 0 ]; then
    E=0
    check_file() {
        if [ -f $1 ]; then
            echo "$1 already exists"
            E=1
        fi
    }
    check_file ${base_dir}/${cfname}.h
    check_file ${base_dir}/${cfname}.c
    check_file ${base_dir}/${cfname}_public.h
    check_file ${base_dir}/${cfname}_public.c
    check_file ${base_dir}/${cfname}_interface.c
    # if [ $gen_make == 1 ]; then
        # check_file ${base_dir}/${cfname}/Makefile.am
    # fi
    for sub in $@; do
        check_file ${base_dir}/${cfname}_${sub}.c
        check_file ${base_dir}/${cfname}_${sub}.h
    done
    if [ $E == 1 ]; then
        echo "remove them or use option -o to overwrite"
        exit 1;
    fi
fi

put_component_c "${base_dir}/${cfname}.c" "${cfname}" "${cname}" "${prefix}" "${header}"
put_component_h "${base_dir}/${cfname}.h" "${cfname}" "${cname}" "${prefix}" "${header}" $@

# # generate each sub component
for sub in $@; do
    put_sub_c "${base_dir}/${cfname}_${sub}.c" "${cfname}" "${cname}" "${prefix}" "${header}" ${sub}
    put_sub_h "${base_dir}/${cfname}_${sub}.h" "${cfname}" "${cname}" "${prefix}" "${header}" ${sub}
done
